"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;
exports.preSerialize = preSerialize;
exports.postDeserialize = postDeserialize;

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function bundledBabelCore() {
  const data = _interopRequireWildcard(require("@babel/core"));

  bundledBabelCore = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _env() {
  const data = _interopRequireDefault(require("./env"));

  _env = function () {
    return data;
  };

  return data;
}

function _jsx() {
  const data = _interopRequireDefault(require("./jsx"));

  _jsx = function () {
    return data;
  };

  return data;
}

function _flow() {
  const data = _interopRequireDefault(require("./flow"));

  _flow = function () {
    return data;
  };

  return data;
}

function _typescript() {
  const data = _interopRequireDefault(require("./typescript"));

  _typescript = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("./utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("./constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TYPESCRIPT_EXTNAME_RE = /^\.tsx?/;

const BABEL_TRANSFORMER_DIR = _path().default.dirname(__dirname);

const JS_EXTNAME_RE = /^\.(js|cjs|mjs)$/;

async function load(config, options, logger) {
  var _ref, _ref2, _options$env$BABEL_EN;

  // Don't transpile inside node_modules
  if (!config.isSource) {
    return;
  }

  let resolved = await options.packageManager.resolve('@babel/core', config.searchPath, {
    range: _constants().BABEL_RANGE,
    shouldAutoInstall: options.shouldAutoInstall
  });
  let babelCore = await options.packageManager.require(resolved.resolved, config.searchPath);
  let babelOptions = {
    filename: config.searchPath,
    cwd: options.projectRoot,
    envName: (_ref = (_ref2 = (_options$env$BABEL_EN = options.env.BABEL_ENV) !== null && _options$env$BABEL_EN !== void 0 ? _options$env$BABEL_EN : options.env.NODE_ENV) !== null && _ref2 !== void 0 ? _ref2 : options.mode === 'production' || options.mode === 'development' ? options.mode : null) !== null && _ref !== void 0 ? _ref : 'development'
  }; // Only add the showIgnoredFiles option if babel is new enough, otherwise it will throw on unknown option.

  if (_semver().default.satisfies((0, _nullthrows().default)(resolved.pkg).version, '^7.12.0')) {
    // $FlowFixMe
    babelOptions.showIgnoredFiles = true;
  }

  let partialConfig = await babelCore.loadPartialConfigAsync(babelOptions); // Invalidate when any babel config file is added.

  config.setWatchGlob('**/{.babelrc,.babelrc.js,.babelrc.json,.babelrc.cjs,.babelrc.mjs,.babelignore,babel.config.js,babel.config.json,babel.config.mjs,babel.config.cjs}');

  let addIncludedFile = file => {
    if (JS_EXTNAME_RE.test(_path().default.extname(file))) {
      logger.warn({
        message: `It looks like you're using a JavaScript Babel config file. This means the config cannot be watched for changes, and Babel transformations cannot be cached. You'll need to restart Parcel for changes to this config to take effect. Try using a ${_path().default.basename(file, _path().default.extname(file)) + '.json'} file instead.`
      });
      config.shouldInvalidateOnStartup();
    } else {
      config.addIncludedFile(file);
    }
  };

  let warnOldVersion = () => {
    logger.warn({
      message: 'You are using an old version of @babel/core which does not support the necessary features for Parcel to cache and watch babel config files safely. You may need to restart Parcel for config changes to take effect. Please upgrade to @babel/core 7.12.0 or later to resolve this issue.'
    });
    config.shouldInvalidateOnStartup();
  }; // Old versions of @babel/core return null from loadPartialConfig when the file should explicitly not be run through babel (ignore/exclude)


  if (partialConfig == null) {
    warnOldVersion();
    return;
  }

  if (partialConfig.files == null) {
    // If the files property is missing, we're on an old version of @babel/core.
    // We need to invalidate on startup because we can't properly track dependencies.
    if (partialConfig.hasFilesystemConfig()) {
      warnOldVersion();

      if (typeof partialConfig.babelrcPath === 'string') {
        addIncludedFile(partialConfig.babelrcPath);
      }

      if (typeof partialConfig.configPath === 'string') {
        addIncludedFile(partialConfig.configPath);
      }
    }
  } else {
    for (let file of partialConfig.files) {
      addIncludedFile(file);
    }
  }

  if (partialConfig.fileHandling != null && partialConfig.fileHandling !== 'transpile') {} else if (partialConfig.hasFilesystemConfig()) {
    config.setResult({
      internal: false,
      config: partialConfig.options,
      targets: (0, _utils2().enginesToBabelTargets)(config.env)
    });
    let {
      hasRequire,
      dependsOnLocal
    } = getStats(partialConfig.options, options); // If the config depends on local plugins or has plugins loaded with require(),
    // we can't cache the result of the compilation. If the config references local plugins,
    // we can't know what dependencies those plugins might have. If the config has require()
    // calls in it to load plugins we can't know where they came from.

    if (dependsOnLocal || hasRequire) {
      config.setResultHash(JSON.stringify(Date.now()));
      config.shouldInvalidateOnStartup();
    }

    if (dependsOnLocal) {
      logger.warn({
        message: "It looks like you are using local Babel plugins or presets. This means Babel transformations cannot be cached and will run on each build. You'll need to restart Parcel for changes to local plugins to take effect."
      });
    } else if (hasRequire) {
      logger.warn({
        message: 'It looks like you are using `require` to configure Babel plugins or presets. This means Babel transformations cannot be cached and will run on each build. Please use strings to configure Babel instead.'
      });
    } else {
      await definePluginDependencies(config);
      config.setResultHash((0, _utils().md5FromObject)(partialConfig.options));
    }
  } else {
    await buildDefaultBabelConfig(options, config);
  }
}

async function buildDefaultBabelConfig(options, config) {
  let jsxOptions = await (0, _jsx().default)(options, config);
  let babelOptions;

  if (_path().default.extname(config.searchPath).match(TYPESCRIPT_EXTNAME_RE)) {
    babelOptions = (0, _typescript().default)(config, jsxOptions === null || jsxOptions === void 0 ? void 0 : jsxOptions.pragma, jsxOptions === null || jsxOptions === void 0 ? void 0 : jsxOptions.pragmaFrag);
  } else {
    babelOptions = await (0, _flow().default)(config, options);
  }

  let babelTargets;
  let envOptions = await (0, _env().default)(config);

  if (envOptions != null) {
    babelTargets = envOptions.targets;
    babelOptions = mergeOptions(babelOptions, envOptions.config);
  }

  babelOptions = mergeOptions(babelOptions, jsxOptions === null || jsxOptions === void 0 ? void 0 : jsxOptions.config);

  if (babelOptions != null) {
    babelOptions.presets = (babelOptions.presets || []).map(preset => bundledBabelCore().createConfigItem(preset, {
      type: 'preset',
      dirname: BABEL_TRANSFORMER_DIR
    }));
    babelOptions.plugins = (babelOptions.plugins || []).map(plugin => bundledBabelCore().createConfigItem(plugin, {
      type: 'plugin',
      dirname: BABEL_TRANSFORMER_DIR
    }));
  }

  config.setResult({
    internal: true,
    config: babelOptions,
    targets: babelTargets
  });
  await definePluginDependencies(config);
}

function mergeOptions(result, config) {
  if (!config || (!config.presets || config.presets.length === 0) && (!config.plugins || config.plugins.length === 0)) {
    return result;
  }

  let merged = result;

  if (merged) {
    merged.presets = (merged.presets || []).concat(config.presets || []);
    merged.plugins = (merged.plugins || []).concat(config.plugins || []);
  } else {
    result = config;
  }

  return result;
}

function getStats(options, parcelOptions) {
  let hasRequire = false;
  let dependsOnLocal = false;
  let configItems = [...options.presets, ...options.plugins];

  for (let configItem of configItems) {
    if (!configItem.file) {
      hasRequire = true;
    } else if (configItem.file.request.startsWith('.') || isLocal(configItem.file.resolved, parcelOptions.inputFS)) {
      dependsOnLocal = true;
    }
  }

  return {
    hasRequire,
    dependsOnLocal
  };
}

function isLocal(configItemPath, fs) {
  return fs.realpathSync(configItemPath) !== configItemPath;
}

function preSerialize(config) {
  var _config$result;

  let babelConfig = (_config$result = config.result) === null || _config$result === void 0 ? void 0 : _config$result.config;

  if (babelConfig == null) {
    return;
  } // ConfigItem.value is a function which the v8 serializer chokes on
  // It is being ommited here and will be rehydrated later using the path provided by ConfigItem.file


  babelConfig.presets = (babelConfig.presets || []).map(({
    options,
    dirname,
    name,
    file
  }) => ({
    options,
    dirname,
    name,
    file
  }));
  babelConfig.plugins = (babelConfig.plugins || []).map(({
    options,
    dirname,
    name,
    file
  }) => ({
    options,
    dirname,
    name,
    file
  }));
}

async function definePluginDependencies(config) {
  let babelConfig = config.result.config;

  if (babelConfig == null) {
    return;
  }

  let configItems = [...babelConfig.presets, ...babelConfig.plugins];
  await Promise.all(configItems.map(async configItem => {
    let pkg = (0, _nullthrows().default)(await config.getConfigFrom(configItem.file.resolved, ['package.json'], {
      parse: true
    })).contents;
    config.addDevDependency(pkg.name, pkg.version);
  }));
}

async function postDeserialize(config, options) {
  let babelCore = config.result.internal ? bundledBabelCore() : await options.packageManager.require('@babel/core', config.searchPath, {
    shouldAutoInstall: options.shouldAutoInstall
  });
  config.result.config.presets = await Promise.all(config.result.config.presets.map(async configItem => {
    let value = await options.packageManager.require(configItem.file.resolved, config.searchPath, {
      shouldAutoInstall: options.shouldAutoInstall
    });
    value = value.default ? value.default : value;
    return babelCore.createConfigItem([value, configItem.options], {
      type: 'preset',
      dirname: configItem.dirname
    });
  }));
  config.result.config.plugins = await Promise.all(config.result.config.plugins.map(async configItem => {
    let value = await options.packageManager.require(configItem.file.resolved, config.searchPath, {
      shouldAutoInstall: options.shouldAutoInstall
    });
    value = value.default ? value.default : value;
    return babelCore.createConfigItem([value, configItem.options], {
      type: 'plugin',
      dirname: configItem.dirname
    });
  }));
}